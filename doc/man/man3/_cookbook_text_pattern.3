.TH "_cookbook.text_pattern" 3 "Wed Sep 17 2014" "Version 0.0.0" "admin-linux" \" -*- nroff -*-
.ad l
.nh
.SH NAME
_cookbook.text_pattern \- 
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "def \fBtest_re_pattern\fP"
.br
.ti -1c
.RI "def \fBtest_shell_pattern\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "def _cookbook\&.text_pattern\&.test_re_pattern ()"

.PP
.nf
Regular Expression (RE) pattern.

re1|re2 - or
re1.re2 - any character except `\n`
^str - start of string
str$ - end of string
re* - 0+ occurrences
re+ - 1+ occurrences
re? - 0 or 1 occurrences
re{N} - N occurrences
re{M,N} - from M to N occurrences
[...] - any single character from character set
[x-y] - any single character from x to y
[^...] - NOT any character from character set
(...) - subgroup

\d - digit, `[0-9]`
\D - NOT digit, `[^0-9]`
\w - alphanumeric character, `[A-Za-z0-9_]`
\W - NOT alphanumeric character, `[^A-Za-z0-9_]`
\s - white space, `[ \n\t\r\v\f]`
\S - NOT white space, `[^ \n\t\r\v\f]`
\bword\b - word boundary
\A - ^
\Z - $
.fi
.PP
 
.PP
Definition at line 30 of file text_pattern\&.py\&.
.SS "def _cookbook\&.text_pattern\&.test_shell_pattern ()"

.PP
.nf
Shell-style wildcards pattern matching.

Pattern | Meaning
---------------------------------------------
*       | matches everything
---------------------------------------------
?       | matches any single character
---------------------------------------------
[seq]   | matches any character in _seq_
---------------------------------------------
[!seq]  | matches any character not in _seq_
---------------------------------------------

For a literal match, wrap the meta-characters in brackets. Note that the
filename separator ('/' on Unix) is not special to `fnmatch` module.

Unlike `fnmatch.fnmatch()`, `glob` module treats file names beginning with
a dot (.) as special cases.

**NOTE**: The matching performed by `fnmatch` module sits somewhere
between the functionality of simple string methods, such as
`startswith()`, `endswith()`, and the full power of regular expressions.
If you're just trying to provide a simple mechanism for allowing wildcards
in data processing operations, it's often a reasonable solution.

.fi
.PP
 
.PP
Definition at line 112 of file text_pattern\&.py\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for admin-linux from the source code\&.
